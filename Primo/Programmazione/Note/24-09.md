---
share: true
---

![LezioneSSRI-1.pdf](../Slides/LezioneSSRI-1.pdf)

## Linguaggio: definizione informale

I linguaggi di programmazione sono dei linguaggi formali.
Hanno 3 livelli di regole:

- **Sintattiche**: regole che determinano come i segni possono essere combinati fra loro.
- **Semantiche**: regole che determinano il significato dei segni e degli enunciati.
- **Pragmatiche**: conseguenze di un enunciato.

Un **alfabeto** è un insieme finito di simboli.

### Le stringhe

Una **stringa** è una sequenza finita di simboli.
**Stringa vuota** $\rightarrow$ $\epsilon$

#### Operazioni sulle stringhe

**Cardinalità** o lunghezza $\rightarrow$ |_s_|
**Kleene Star** $\rightarrow$ funzione che crea tutte le possibile stringhe a partire da un alfabeto.
**Chiusura positiva** $\Sigma^+$ $\rightarrow$ come la Kleene Star ma senza la stringa vuota.
**Concatenazione** $\rightarrow$ $a+b=ab$
**Concatenazione multipla** $\rightarrow$ $a^n$
**Sottostringa**

### I linguaggi

Un **linguaggio formale** è un insieme di parole su un alfabeto.

- Un linguaggio L è un sottoinsieme delle parole costruibili su un alfabeto $\Sigma, L \subseteq \Sigma^*$
- **Simboli** o **token** $\rightarrow$ elementi atomici di un enunciato
- **Parola** $\rightarrow$ stringa di un alfabeto

> **Linguaggio vuoto**
> è un linguaggio che non contiene nessuna parola

#### Operazioni sui linguaggi:

- **Cardinalità** $\rightarrow$ numero di stringhe che lo compongono
- **Concatenazione** $\rightarrow$ $L_c=L_1L_2$
- **Potenza n-esima** $\rightarrow$ tutte le stringhe ottenute concatenando le n stringhe di $L$, incluse le ripetizioni
- **Chiusura** $L^*$ $\rightarrow$ tutte le n-esime potenze di $L$
- **Chiusura positiva** $L^+$ $\rightarrow$ chiusura con $n >0$

### I codici

Un linguaggio si dice **codice** quando:

- È **univocamente decifrabile**
- Data una parola in L+ esiste un solo modo di ottenerla come prodotto di parole di L
- nessuna parola è **prefisso** di un'altra parola
    > **Esempio** > $C=\{1,10\}$ è un codice
    > $C'=\{bab, aba, ab\}$ non è un codice

### Appartenenza a un linguaggio

Consideriamo una parola o frase w e un linguaggio L. Abbiamo due possibilità:

- w **appartiene** al linguaggio L $\rightarrow$ $w \in L$
- w **non appartiene** al linguaggio L $\rightarrow$ $w \notin L$

#### Approcci

Esistono due approcci per determinare se una parola è valida in un certo linguaggio:

- **Approccio riconoscitivo**
    - Si possono utilizzare gli **automi a stati finiti** (vedo se riesco a riconoscerla)
- **Approccio generativo**
    - Si usa la **grammatica** (vedo se riesco a generarla)

## Automi a stati finiti

> **Definizione**
> È un modello matematico che dato un ingresso discreto dà un'uscita discreta.

Un automa finito M su un alfabeto $\Sigma$ è una quintupla $<K, \Sigma, Delta, q_0, F>$

- $K$ è un insieme finito e non vuoto di stati in cui si può trovare $M$
- $\Sigma$ è un alfabeto finito di simboli in ingresso
- $\delta: K \times\Sigma \rightarrow K$ è la funzione di transizione di stato
- $q_0\in K$ è lo stato iniziale
- $F\subseteq K$ è l'insieme degli stati finali (1 o più di uno)

**Rappresentazione grafica**
Il seguente grafico mostra una transizione dallo stato _q_ allo stato _p_ ricevuto l'ingresso _a_
![Screenshot 2025-09-27 alle 16.39.11](../../../Immagini/Screenshot%202025-09-27%20alle%2016.39.11.png)
Nodi $\rightarrow$ stati
Archi $\rightarrow$ transizioni

### Riconoscitore di un linguaggio

- **Funziona come una _black box_:**
    - _ingresso:_ parole costruite su un alfabeto finito $S=\{S_1,S_2,\dots,S_n\}$
    - _uscita:_ un valore in $\{0,1\}$
- **Funzionamento:**
    - Riceve in ingresso delle parole $w\in S^*$
    - Ritorna in uscita $1$ se la parola appartiene al linguaggio, $0$ se non appartiene

> **Si modella attraverso un automa a stati**

#### Esempio erogatore di bibite da 50 cent

- Accetta monete da 10cent e 20cent, S={10, 20}
- Non da resto
- Rifiuta tutte le monete che portano a superare i 50 centesimi
    È una macchina a stati finiti che riconosce un linguaggio composto da parole su S: eroga la bibita quando la parola è accettata.

> Non è un automa completamente specificato.

![Screenshot 2025-09-27 alle 16.50.16](../../../Immagini/Screenshot%202025-09-27%20alle%2016.50.16.png)

#### Linguaggio delle soluzioni

Grafo dell'automa $\rightarrow$ definisce il linguaggio delle soluzioni

- $x\in\{l,p,c,b\}^*$ | _iniziando in uno stato iniziale e seguendo gli archi definiti da x si arriva nello stato finale_
    > **Il linguaggio è infinito**

### Proprietà

- Dinamico
- Discreto
- Simboli finiti

### Tipologie

- Deterministici -> per ogni input esiste una sola transizione
- Non deterministici -> più stati raggiungibili con un input
    Il determinismo è un caso particolare di non determinismo.

### Macchine a stati che generano output

- **Macchina di Mealy**: genera l'output sulla transizione di stato
- **Macchina di Moore**: genera l'output in funzione dello stato

### La macchina di Turing

La macchina di Turing anziché avere a che fare con insiemi finiti, lavora con memoria infinita, è dunque più potente dell'elaboratore moderno.
Si basa sugli automi a stati finiti.

> Permette di analizzare e definire il concetto di **algoritmo**.

Serve per calcolare:

- calcolabilità
- complessità
- equivalenza di algoritmi

> La **Macchina di Turing** (MdT) è una macchina basata su un automa a stati finiti) avente **nastro potenzialmente infinito**.

- Automa $\rightarrow$ **dispositivo di controllo**
- Nastro $\rightarrow$ **sequenza di celle**, sulla quale agisce una testina che può leggere e scrivere in ogni cella
    - un alfabeto predefinito
- le celle possono essere **vuote**
    ![Screenshot 2025-09-30 alle 14.56.03](../../../Immagini/Screenshot%202025-09-30%20alle%2014.56.03.png)

#### Operazioni della testina

- **Spostamento** di una posizione
- **Scrittura** o **lettura** di un **simbolo**

> La macchina di Turing **calcola una funzione**

#### Definizione formale

> Tabella delle transizioni di stato

Una quintupla di elementi:

- _s_: stato della macchina nell'istante presente
- _i_: il simbolo letto all'istante presente
- _S(s,i)_: lo stato della macchia all'istante successivo
- V(s,i): il verso del movimento della macchina
    ![Screenshot 2025-09-30 alle 15.10.05](../../../Immagini/Screenshot%202025-09-30%20alle%2015.10.05.png) Esempio di programma scritto nel linguaggio della Macchina di Turing. È un codice perché le parole sono sempre tutte uguali.

> Il programma è codificato nell'automa

La MdT è un esecutore di algoritmi, in grado si eseguire qualsiasi algoritmo

> **Algoritmo** definizione 1: procedura per risolvere "meccanicamente" una classe di problemi predefiniti.
> **Algoritmo** definizione 2: una MdT che si arresti trasformando il nastro da _t_ a _t'_ rappresenta l'elaborazione per _Y = F(X)_

Gli elaboratori moderni sono delle macchine di Turing che prendono in ingresso altre macchine di Turing e le esegue $\rightarrow$ MdT Universale (MdTU)

La memoria RAM è l'equivalente del nastro nella MdT

> Avere programma, input, output sulla stessa memoria è un problema di sicurezza (overflow)

![LezioneSSRI-1 Esercizi.pdf](../Slides/LezioneSSRI-1%20Esercizi.pdf)

# Esercizi

- Considerando il linguaggio definito sull’alfabeto {a,b,c} descrivere la macchina a stati che riconosce tutte le parole che contengono **acb**. ![Screenshot 2025-10-01 alle 17.03.01](../../../Immagini/Screenshot%202025-10-01%20alle%2017.03.01.png)

|        | a   | b   | c   |
| ------ | --- | --- | --- |
| **q0** | q1  | q0  | q0  |
| **q1** | q1  | q0  | q2  |
| **q2** | q1  | q3  | q0  |
| **q3** | q3  | q3  | q3  |

- Supponiamo di voler modellare un sistema che riconosce delle firme sempici di un virus all’interno di un file. Tale firma è costituita sull’alfabeto {a,b,c} e determinata dalla sequenza **aabb** oppure **abcc**, all’interno di un file.
    - Descrivere la macchina a stati che identifica i file contenenti questa firma. Considerare un file come una sequenza di caratteri. La firma non può essere all’inizio del file ma solo all’interno o alla fine.
        ![Screenshot 2025-10-01 alle 18.10.34](../../../Immagini/Screenshot%202025-10-01%20alle%2018.10.34.png)

|        | **a** | **b** | **c** |
| ------ | ----- | ----- | ----- |
| **q0** | q1    | q1    | q1    |
| **q1** | q2    | q1    | q1    |
| **q2** | q3    | q4    | q1    |
| **q3** | q3    | q7    | q1    |
| **q4** | q1    | q2    | q5    |
| **q5** | q2    | q1    | q6    |
| **q6** | q6    | q6    | q6    |
| **q7** | q2    | q8    | q1    |
| **q8** | q8    | q8    | q8    |

- Supponiamo di voler modellare un sistema Big Data Streaming in cui arriva un flusso di dati dai sensori di una catena di produzione di cui serve monitorarne l’andamento. I simboli dello stream appartengono all’alfabeto {a,b,c}, il carattere \* indica uno e un solo carattere qualsiasi dell’alfabeto.
    - Descrivere la macchina a stati che identifica flussi contenenti la sequenza ab\*c, che identifica un malfunzionamento.
        ![Screenshot 2025-10-02 alle 18.00.08](../../../Immagini/Screenshot%202025-10-02%20alle%2018.00.08.png)

|     | a   | b   | c   |
| --- | --- | --- | --- |
| q0  | q1  | q0  | q0  |
| q1  | q1  | q2  | q0  |
| q2  | q3  | q3  | q3  |
| q3  | q1  | q0  | q4  |
| q4  | q4  | q4  | q4  |

- Programmare una macchina di Turing che esegue il complemento dei bit nella posizione pari, e lascia inalterati quelli nella posizione dispari.
    - Es. 111 $\rightarrow$ 010

```
(0,1,1,1,>)
(1,1,0,0,>)
(1,-,END,-,-)
(0,-,END,-,-)
```

- Programmare una Macchina di Turing che, dato un nastro iniziale contenente una sequenza di A e B , termina la sua esecuzione lasciando sul nastro una sola T se la sequenza iniziale contiene almeno una B, una sola F altrimenti.

```
(0,A,0,-,>)
(1,A,1,-,>)
(0,B,1,-,>)
(1,B,1,-,>)
(1,-,END,T,-)
(0,-,END,F,-)
```

- Programmare una Macchina di Turing che, dato un nastro iniziale contenente una sequenza di cifre decimali, termina la sua esecuzione lasciando sul nastro la sequenza che si ottiene eliminando tutte le cifre 0 alla sinistra della cifra diversa da 0 più a sinistra. Se la sequenza iniziale è composta da sole cifre 0, la macchina deve lasciare sul nastro un solo 0.

```
(0,0,0,-,>)
(0,1,END,1,-)
(0,2,END,2,-)
(0,3,END,3,-)
(0,4,END,4,-)
(0,5,END,5,-)
(0,6,END,6,-)
(0,7,END,7,-)
(0,8,END,8,-)
(0,9,END,9,-)
(0,-,END,0,-)
```

- Il distributore ha due pulsanti, tè (t) o caffè (c).
    Il tè costa 30 centesimi, il caffè costa 60 centesimi.
    Il distributore accetta monete da 10,20,50 centesimi ed eroga il prodotto solo se si raggiunge la cifra esatta, dopo aver premuto il pulsante della bevanda scelta.

```
(0,c,1,c,>)
(0,t,2,t,>)
(1,1,10,1,>)
(1,2,20,2,>)
(1,5,50,5,>)
(10,5,END,6,-)
(10,2,30,3,>)
(10,1,20,2,>)
(30,1,40,4,>)
(30,2,50,5,>)
(40,1,50,5,>)
(40,2,END,6,-)
(50,1,END,6,-)
(20,1,30,3,>)
(20,2,40,4,>)
(2,1,010,1,>)
(2,2,020,2,>)
(010,1,020,2,>)
(010,2,END,3,-)
(020,1,END,3,-)
```

- Dato un numero intero positivo n, n div 2 è il quoziente della divisione di n per 2. Ad esempio, 6 div 2 = 3 , mentre 9 div 2 = 4 . Consideriamo il problema di programmare una macchina di Turing che, dato un nastro iniziale contenente una sequenza composta da nA consecutive (con n > 1), termina la sua esecuzione lasciando sul nastro la sequenza composta da n div 2 A consecutive.

```
non ne ho la più pallida idea
```

- Una sequenza si dice palindroma se la sua lettura da sinistra verso destra è uguale alla sua lettura da destra verso sinistra. Programmare una Macchina di Turing che, dato un nastro iniziale contenente una sequenza di A e B, termina la sua esecuzione lasciando sul nastro la sola S se la sequenza iniziale è palindroma.
    - L’idea è quella di leggere il primo a sinistra e l’ultimo a destra per vedere se sono lo stesso carattere e nel caso cancellarli.

```
ma io che cazzo ne so
```
