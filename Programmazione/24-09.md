## Linguaggio: definizione informale
I linguaggi di programmazione sono dei linguaggi formali.
Hanno 3 livelli di regole:
- **Sintattiche**: regole che determinano come i segni possono essere combinati fra loro.
- **Semantiche**: regole che determinano il significato dei segni e degli enunciati.
- **Pragmatiche**: conseguenze di un enunciato.

Un **alfabeto** è un insieme finito di simboli.
### Le stringhe
Una **stringa** è una sequenza finita di simboli.
**Stringa vuota** $\rightarrow$ $\epsilon$
#### Operazioni sulle stringhe
**Cardinalità** o lunghezza $\rightarrow$ |*s*|
**Kleene Star** $\rightarrow$ funzione che crea tutte le possibile stringhe a partire da un alfabeto.
**Chiusura positiva** $\Sigma^+$ $\rightarrow$ come la Kleene Star ma senza la stringa vuota.
**Concatenazione** $\rightarrow$ $a+b=ab$
**Concatenazione multipla** $\rightarrow$ $a^n$
**Sottostringa**
### I linguaggi
Un **linguaggio formale** è un insieme di parole su un alfabeto.
- Un linguaggio L è un sottoinsieme delle parole costruibili su un alfabeto $\Sigma, L \subseteq \Sigma^*$ 
- **Simboli** o **token** $\rightarrow$ elementi atomici di un enunciato
- **Parola** $\rightarrow$ stringa di un alfabeto

> **Linguaggio vuoto**
> è un linguaggio che non contiene nessuna parola
#### Operazioni sui linguaggi:
- **Cardinalità** $\rightarrow$ numero di stringhe che lo compongono
- **Concatenazione** $\rightarrow$ $L_c=L_1L_2$
- **Potenza n-esima** $\rightarrow$ tutte le stringhe ottenute concatenando le n stringhe di $L$, incluse le ripetizioni
- **Chiusura** $L^*$ $\rightarrow$ tutte le n-esime potenze di $L$
- **Chiusura positiva** $L^+$ $\rightarrow$ chiusura con $n >0$

### I codici
Un linguaggio si dice **codice** quando:
- È **univocamente decifrabile**
- Data una parola in L+ esiste un solo modo di ottenerla come prodotto di parole di L
- nessuna parola è **prefisso** di un'altra parola
> **Esempio**
> $C=\{1,10\}$ è un codice
> $C'=\{bab, aba, ab\}$ non è un codice

### Appartenenza a un linguaggio
Consideriamo una parola o frase w e un linguaggio L. Abbiamo due possibilità:
- w **appartiene** al linguaggio L $\rightarrow$ $w \in L$
- w **non appartiene** al linguaggio L $\rightarrow$ $w \notin L$
#### Approcci
Esistono due approcci per determinare se una parola è valida in un certo linguaggio:
- **Approccio riconoscitivo**
	- Si possono utilizzare gli **automi a stati finiti** (vedo se riesco a riconoscerla)
- **Approccio generativo**
	- Si usa la **grammatica** (vedo se riesco a generarla)

## Automi a stati finiti
> **Definizione**
> È un modello matematico che dato un ingresso discreto dà un'uscita discreta.

==Un automa finito M su un alfabeto $\Sigma$ è una quintupla $<K, \Sigma, Delta, q_0, F>$==
- ==$K$ è un insieme finito e non vuoto di stati in cui si può trovare $M$==
- ==$\Sigma$ è un alfabeto finito di simboli in ingresso==
- ==$\delta: K \times\Sigma \rightarrow K$ è la funzione di transizione di stato==
- ==$q_0\in K$ è lo stato iniziale==
- ==$F\subseteq K$ è l'insieme degli stati finali (1 o più di uno)==

**Rappresentazione grafica**
Il seguente grafico mostra una transizione dallo stato *q* allo stato *p* ricevuto l'ingresso *a*
![[Screenshot 2025-09-27 alle 16.39.11.png]]
Nodi $\rightarrow$ stati
Archi $\rightarrow$ transizioni
### Riconoscitore di un linguaggio
- **Funziona come una *black box*:**
	- *ingresso:* parole costruite su un alfabeto finito $S=\{S_1,S_2,\dots,S_n\}$
	- *uscita:* un valore in $\{0,1\}$
- **Funzionamento:**
	- Riceve in ingresso delle parole $w\in S^*$
	- Ritorna in uscita $1$ se la parola appartiene al linguaggio, $0$ se non appartiene

> **Si modella attraverso un automa a stati**
#### Esempio erogatore di bibite da 50 cent
- Accetta monete da 10cent e 20cent, S={10, 20}
- Non da resto
- Rifiuta tutte le monete che portano a superare i 50 centesimi
È una macchina a stati finiti che riconosce un linguaggio composto da parole su S: eroga la bibita quando la parola è accettata.

> Non è un automa completamente specificato.

![[Screenshot 2025-09-27 alle 16.50.16.png]]
#### Linguaggio delle soluzioni
Grafo dell'automa $\rightarrow$ definisce il linguaggio delle soluzioni
- $x\in\{l,p,c,b\}^*$ | *iniziando in uno stato iniziale e seguendo gli archi definiti da x si arriva nello stato finale*  
> **Il linguaggio è infinito**
### Proprietà
- Dinamico
- Discreto
- Simboli finiti
### Tipologie
- Deterministici -> per ogni input esiste una sola transizione
- Non deterministici -> più stati raggiungibili con un input
Il determinismo è un caso particolare di non determinismo.
### Macchine a stati che generano output
- **Macchina di Mealy**: genera l'output sulla transizione di stato
- **Macchina di Moore**: genera l'output in funzione dello stato

### La macchina di Turing
La macchina di Turing anziché avere a che fare con insiemi finiti, lavora con memoria infinita, è dunque più potente dell'elaboratore moderno.
Si basa sugli automi a stati finiti.

> Permette di analizzare e definire il concetto di **algoritmo**.

Serve per calcolare:
- calcolabilità
- complessità
- equivalenza di algoritmi

> La **Macchina di Turing** (MdT) è una macchina basata su un automa a stati finiti) avente **nastro potenzialmente infinito**.

- Automa $\rightarrow$ **dispositivo di controllo**
- Nastro $\rightarrow$ **sequenza di celle**, sulla quale agisce una testina che può leggere e scrivere in ogni cella
	- un alfabeto predefinito
- le celle possono essere **vuote**
![[Screenshot 2025-09-30 alle 14.56.03.png]]
#### Operazioni della testina
- **Spostamento** di una posizione
- **Scrittura** o **lettura** di un **simbolo**

> La macchina di Turing **calcola una funzione**

#### Definizione formale
> Tabella delle transizioni di stato

Una quintupla di elementi:
- *s*: stato della macchina nell'istante presente
- *i*: il simbolo letto all'istante presente
- *S(s,i)*: lo stato della macchia all'istante successivo
- V(s,i): il verso del movimento della macchina
![[Screenshot 2025-09-30 alle 15.10.05.png]]  Esempio di programma scritto nel linguaggio della Macchina di Turing. È un codice perché le parole sono sempre tutte uguali.

> ==Il programma è codificato nell'automa==

La MdT è un esecutore di algoritmi, in grado si eseguire qualsiasi algoritmo
> **Algoritmo** definizione 1: procedura per risolvere "meccanicamente" una classe di problemi predefiniti.
> **Algoritmo** definizione 2:  una MdT che si arresti trasformando il nastro da *t* a *t'* rappresenta l'elaborazione per *Y = F(X)*

Gli elaboratori moderni sono delle macchine di Turing che prendono in ingresso altre macchine di Turing e le esegue $\rightarrow$ MdT Universale (MdTU)

La memoria RAM è l'equivalente del nastro nella MdT

> Avere programma, input, output sulla stessa memoria è un problema di sicurezza (overflow)

# Esercizi
- Considerando il linguaggio definito sull’alfabeto {a,b,c} descrivere la macchina a stati che riconosce tutte le parole che contengono acb. ![[Immagini/Screenshot 2025-10-01 alle 17.03.01.png]]
- 
