---
share: true
---
![Architettura01](../Slides/Architettura01.pdf)
## Sistema binario
Sistema con base 2.
Bit più a sinistra $\rightarrow$ bit più significativo (MSD: most significant digit)
Bit più a destra $\rightarrow$ bit meno significativo (LSD: less significant digit)

## Sistema a base r
- *r* simboli distinti (0,1,2,...,r-1)
- moltiplicati per potenze intere di *r*:
$$\large x_{n-1}\cdot r^{n-1}+x_{n-2}\cdot r^{n-2}+...+x_1\cdot r^1+x_0\cdot r^0+x^{-1}\cdot r^{-1}+...+x_{-m+1}\cdot r^{-m+1}+x_{-m}\cdot r^{-m}$$
- notazione posizionale:
$$\large x_{n-1},x_{n-2},...,x_1,x_0,x_{-1},x_{-2},...,x_{-m+1},x_{-m}$$
### Da base r a base 10
$$(x_1,x_0,x_{-1})_r=(x_1r^1+x_0r^0+x_{-1}r^{-1})_{10}$$
### Da base 10 a base r (numeri interi)
``` c
i=1;
while (n!=0){
	m = n % r; // modulo
	n = n / r; // divisione intera
	i++;
}
```
### Da base 10 a base r (numeri decimali)
``` c
i = 1;
while (n!=0 && 1<=p){
	m = n * r; // prodotto (parte intera)
	n = n * r; // prodotto (parte decimale)
	i++;
}
```
>Bisogna specificare una **precisione *p***, altrimenti si andrebbe avanti all'infinito.

Se ho sia la parte prima della virgola che quella dopo faccio i due algoritmi e poi metto tutto insieme.

## Numeri ottali ed esadecimali
![Screenshot 2025-09-26 alle 12.38.53](../../Immagini/Screenshot%202025-09-26%20alle%2012.38.53.png)
### Da binario ad ottale
- Si divide il binario in gruppi di **tre** bit a partire dalla virgola
- Ogni gruppo da 3 rappresenta una cifra ottale
> I numeri ottali si rappresentano con uno 0 davanti

Per la conversione inverse si esegue semplicemente il processo inverso.
### Da binario a esadecimale
- Si divide il binario in gruppi di **quattro** bit a partire dalla virgola
- Ogni gruppo da 4 rappresenta una cifra esadecimale
> I numeri esadecimali si rappresentano con uno 0x davanti

Per la conversione inverse si esegue semplicemente il processo inverso.
## Addizione di binari
> Come la somma base 10 (con il resto)

![Screenshot 2025-09-26 alle 13.43.14](../../Immagini/Screenshot%202025-09-26%20alle%2013.43.14.png)

## Intervalli numerici (unsigned)
In un computer l'intervallo dei valori rappresentabili dipende dal numero di bit disponibili (N).
Nel caso di **interi senza segno**:
$$[0, 2^N-1]$$
### Overflow
> Un **overflow** si verifica nel momento in cui la somma eccede l'intervallo di rappresentazione e non è dunque rappresentabile.

![Screenshot 2025-09-26 alle 13.53.56](../../Immagini/Screenshot%202025-09-26%20alle%2013.53.56.png)

## Differenza di binari
> Come la differenza base 10 (con il prestito)

- Se il sottraendo è più piccolo del minuendo
	![Screenshot 2025-09-26 alle 13.57.05](../../Immagini/Screenshot%202025-09-26%20alle%2013.57.05.png)
- Se il minuendo è più piccolo del sottraendo
	![Screenshot 2025-09-26 alle 13.59.53](../../Immagini/Screenshot%202025-09-26%20alle%2013.59.53.png)

## Prodotto di binari
> Come il prodotto in base 10 (sommando poi i prodotti parziali)

![Screenshot 2025-09-26 alle 14.03.32](../../Immagini/Screenshot%202025-09-26%20alle%2014.03.32.png)

## Rappresentazione con N bit
- Con *N* bit posso rappresentare $2^N$ valori
- Se ho *M* valori da rappresentare mi servono $\lceil log_2M\rceil$ bit (**parte intera superiore** del logaritmo)
- Se ho *M* valori da rappresentare mi servono $\lceil log_2M\rceil$ in base *r*

> **Esempio**
> Per rappresentare 14 valori ho bisogno di $\lceil log_214\rceil=\lceil3,807\dots\rceil=4bit$ 

## Modulo e segno
Si utilizza un tot di bit per il modulo e un solo bit per il segno.
L'intervallo di rappresentazione con N bit è: $[-2^{N-1}+1,2^{N-1}-1]$
> **Problema:**
> lo zero si può rappresentare in due modi. +0 e -0

## Complemento a 2
![Screenshot 2025-09-26 alle 14.23.13](../../Immagini/Screenshot%202025-09-26%20alle%2014.23.13.png)
L'intervallo di rappresentazione con *N* bit è: $[-2^{N-1},2^{N-1}-1]$
### Da decimale a binario
- se il numero intero decimale è positivo si fa come la rappresentazione senza segno
- se il numero è negativo si rappresenta come $2^N+x$
#### Cambio di segno
Ricopio le cifre da destra a sinistra fino al primo 1 (compreso) e poi complemento le rimanenti.![Screenshot 2025-09-26 alle 14.27.38](../../Immagini/Screenshot%202025-09-26%20alle%2014.27.38.png)

# Esercizi
### Convertire da base *r* a base 10
1. $r=2$    $11010,101_2$
```math-tex
2^4+2^3+2^1+2^-1+2^-3
```
2. $r=8$    $4156,27_8$
```math-tex
4*8^3+1*8^2+5*8^1+6*8^0+2*8^-1+7*8^-2
```
3. $r=16$    $A8F,B_{16}$
```math-tex
10*16^2+8*16^1+15*16^0+11*16^-1
```
### Convertire da base 10
1. a base 2 il numero 4526,76 con precisione p=5
```math-tex
int = 4526

r1 = int%2
d1 = floor(int/2)
r2 = d1%2
d2 = floor(d1/2)
r3 = d2%2
d3 = floor(d2/2)
r4 = d3%2
d4 = floor(d3/2)
r5 = d4%2
d5 = floor(d4/2)
r6 = d5%2
d6 = floor(d5/2)
r7 = d6%2
d7 = floor(d6/2)
r8 = d7%2
d8 = floor(d7/2)
r9 = d8%2
d9 = floor(d8/2)
r10 = d9%2
d10 = floor(d9/2)
r11 = d10%2
d11 = floor(d10/2)
r12 = d11%2
d12 = floor(d11/2)
r13 = d12%2
d13 = floor(d12/2)
```
```math-tex
dec = 0.76

m1 = fix(dec*2)
m2 = fix((dec*2 - fix(dec*2))*2)
m3 = fix((m2*2 - fix(m2*2))*2)
m4 = fix((m3*2 - fix(m3*2))*2)
m5 = fix((m4*2 - fix(m4*2))*2)
```
> **risultato** $\rightarrow$ 1000110101110,11

2. a base 2 il numero 4526,75 con precisione p=5
```math-tex
dec = 0.75

m1 = fix(dec*2)
m2 = fix((dec*2 - fix(dec*2))*2)
m3 = fix((m2*2 - fix(m2*2))*2)
m4 = fix((m3*2 - fix(m3*2))*2)
m5 = fix((m4*2 - fix(m4*2))*2)
```
> **risultato** $\rightarrow$  1000110101110,11

3. a base 8 il numero 23,2 con precisione p=3
```math-tex
int = 23

r1 = int%8
d1 = floor(int/8)
r2 = d1%8
d2 = floor(d1/8)
```
```math-tex
dec = 0.2

m1 = fix(dec*8)
m2 = fix((dec*8 - fix(dec*8))*8)
m3 = fix((m2*8 - fix(m2*8))*8)
```
>**risulaltato** $\rightarrow$ 27,14

4. a base 16 il numero 270,12 con precisione p=3
```math-tex
int = 270

r1 = int%16
d1 = floor(int/16)
r2 = d1%16
d2 = floor(d1/16)
r3 = d2%16
d3 = floor(d2/16)
```
```math-tex
dec = 0.12

m1 = fix(dec*16)
m2 = fix((dec*16 - fix(dec*16))*16)
m3 = fix((m2*16 - fix(m2*16))*16)
```
> **risultato** $\rightarrow$ 10e,1e

### Convertire da base 2 a base 8 e 16 e viceversa
1.  $1010111001_2$
ottale
```math-tex
o1 = 2^0
o2 = 2^0+2^1+2^2
o3 = 2^1
o4 = 2^0
```
> **risultato** $\rightarrow$ 1271

esadecimale
```math-tex
e1 = 2^0+2^3
e2 = 2^0+2^1+2^3
e3 = 2^1
```
> **risultato** $\rightarrow$ 2b9

2.  $11101110000_2$
ottale
```math-tex
o1 = 0
o2 = 2^1+2^2
o3 = 2^0+2^2
o4 = 2^0+2^1
```
> **risultato** $\rightarrow$ 3560

esadecimale
```math-tex
e1 = 0
e2 = 2^0+2^1+2^2
e3 = 2^0+2^1+2^2
```
> **risultato** $\rightarrow$ 770

### Somma, sottrazione e moltiplicazione
1. 
	11010 +
	00101 =
	------
	11111

	11010 -
	00101 =
	------
	10000

### Qual è l'intervallo di rappresentazione di binari senza segno con 10 cifre? 
```math-tex
2^10
```

### Rappresentare i numeri $85_{10}$ e $-85_{10}$ con $N=8$
modulo e segno
$$101010101$$
complemento a 2
$$10101011$$

### Quanti bit mi servono per rappresentare le 21 lettere dell'alfabeto italiano?
```math tex
ceil(log2(21))
```
